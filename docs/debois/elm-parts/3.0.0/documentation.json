[
  {
    "name": "Parts",
    "comment": " \n\nGiven a TEA component with model type `model` and message type `msg`, we construct\na variant component which knows how to extract its model from a c model\n`c` and produces generic messages `Msg c`. The consuming component is assumed\nto have message type `obs` (for \"observation\"). \n\n# Elm Architecture types\n@docs Update, View\n\n# Model embeddings \n@docs Get, Set, embedView, embedUpdate\n@docs accessors, Accessors\n\n## Indexed model embeddings\n@docs Index, Indexed, indexed\n\n# Message embeddings\n@docs Msg, update, pack\n\n# Part construction\n@docs create, create1\n\n# Lazyness\n\nRecall that `Html.Lazy` avoids re-computing views when the model doesn't change\nacross updates. However, \"doesn't change\" does not mean `model == model'` but rather\nthe stricter `model === model'` (in Javascript terms). That is, the old and new model\nmust not only be structurally the same, they must be literally the same\ndata-structure in memory.  \n\nParts generally do not achieve referential equality of no-op updates, since we\nare wrapping updates conceptually like this: \n\n    let (submodel, submsgs) = SubComponent.update msg model.submodel \n        model' = { model | submodel = submodel }\n    in \n        ...\nIn the second line, even if `submodel == model.submodel` and so `model ==\nmodel'`, we won't have (in Javascript terms) `model === model'`. \n\nIf you need lazy and thus referential equality of no-op updates, use \n`update'` below instead of the regular `update`, and create your parts with \n`create1'`, `pack'` etc. These functions all require that your base `update`\nfunction has the type of `Update'`, that is, wraps the resulting model in \n`Maybe` and explicitly signals a no-op by returning a `Nothing` model. \n\n@docs Update', update', create1', pack', embedUpdate'\n\n",
    "aliases": [
      {
        "name": "Accessors",
        "comment": " For components where consumers do care about the model of the \ncomponent, use the `accessors` function below to generate suitable, \nwell, accessors.\n",
        "args": [
          "model",
          "c"
        ],
        "type": "{ get : Parts.Get model c , set : Parts.Set model c , map : (model -> model) -> c -> c , reset : c -> c }"
      },
      {
        "name": "Get",
        "comment": " Type of \"getter\": fetch component model `m` from c model `c`. \n",
        "args": [
          "model",
          "c"
        ],
        "type": "c -> model"
      },
      {
        "name": "Index",
        "comment": " Type of indices. An index is a list of `Int` rather than just an `Int` to \nsupport nested dynamically constructed elements: Use indices `[0]`, `[1]`, ...\nfor statically known top-level components, then use `[0,0]`, `[0,1]`, ...\nfor a dynamically generated list of components. \n",
        "args": [],
        "type": "List Int"
      },
      {
        "name": "Indexed",
        "comment": " Indexed families of things.\n",
        "args": [
          "a"
        ],
        "type": "Dict.Dict Parts.Index a"
      },
      {
        "name": "Set",
        "comment": " Type of \"setter\": update component model `m` in c `c`. \n",
        "args": [
          "model",
          "c"
        ],
        "type": "model -> c -> c"
      },
      {
        "name": "Update",
        "comment": " Standard TEA update function type. \n",
        "args": [
          "model",
          "msg"
        ],
        "type": "msg -> model -> ( model, Platform.Cmd.Cmd msg )"
      },
      {
        "name": "Update'",
        "comment": " TEA update function with explicit no-op. You should have:\n\n    fst (update msg model) == Nothing       -- No change to model\n    fst (update msg model) == Just model'   -- Change to model'\n\n",
        "args": [
          "model",
          "msg"
        ],
        "type": "msg -> model -> ( Maybe.Maybe model, Platform.Cmd.Cmd msg )"
      },
      {
        "name": "View",
        "comment": " Standard TEA view function type. \n",
        "args": [
          "model",
          "a"
        ],
        "type": "model -> a"
      }
    ],
    "types": [
      {
        "name": "Msg",
        "comment": " Similar to how embeddings enable collecting models of different type\nin a single model c, we collect messages in a single \"master\nmessage\" type. Messages exist exclusively to be dispatched by a corresponding\n`update` function; we can avoid distinguishing between different types of \nmessages by dispatching not the `Msg` itself, but a partially applied update\nfunction `update msg`. \n\nIt's instructive to compare `Msg` to the type of `update` partially applied to \nan actual carried message `m`:\n\n    update : m -> c -> (c, Cmd m)\n    (update m) : c -> (c, Cmd m)\n",
        "args": [
          "c"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "accessors",
        "comment": " Generate accessors.\n",
        "type": "Parts.Get (Parts.Indexed model) c -> Parts.Set (Parts.Indexed model) c -> model -> Parts.Index -> Parts.Accessors model c"
      },
      {
        "name": "create",
        "comment": " From `update` and `view` functions, produce a `view` function which (a) \nfetches its model from a `c` model, and (b) dispatches generic `Msg`\nmessages. \n\nIts instructive to compare the types of the input `view` and `update` for a \ntypical case. Notice that `create` transforms `model` -> `c` and\n`Html m` -> `Html (Msg c)`. \n\n  {- Input -}\n  view : (m -> obs) -> model -> List (Attributes m) -> List (Html m) -> Html m\n  update : m -> model -> (model, Cmd m)\n\n  {- Output -}\n  type alias m' = Msg c\n  view : c -> List (Attributes m') -> List (Html m') -> Html m'\n\nNote that the input `view` function is assumed to take a function lifting its\nmessages. \n\n",
        "type": "((m -> obs) -> Parts.View model a) -> Parts.Update model m -> Parts.Get (Parts.Indexed model) c -> Parts.Set (Parts.Indexed model) c -> model -> (Parts.Msg c -> obs) -> Parts.Index -> Parts.View c a"
      },
      {
        "name": "create1",
        "comment": " Like `create`, but for components that are assumed to have only one\ninstance.\n",
        "type": "((msg -> obs) -> Parts.View model a) -> Parts.Update model msg -> Parts.Get model c -> Parts.Set model c -> (Parts.Msg c -> obs) -> Parts.View c a"
      },
      {
        "name": "create1'",
        "comment": " Like `create1`, but for explicit no-op update functions. \n",
        "type": "((msg -> obs) -> Parts.View model a) -> Parts.Update' model msg -> Parts.Get model c -> Parts.Set model c -> (Parts.Msg c -> obs) -> Parts.View c a"
      },
      {
        "name": "embedUpdate",
        "comment": " Lift an `Update` from operating on `model` to a c model `c`. \n",
        "type": "Parts.Get model c -> Parts.Set model c -> Parts.Update model msg -> Parts.Update c msg"
      },
      {
        "name": "embedUpdate'",
        "comment": " Lift an explicit no-op `Update'` from operating on `model` to a c model `c`. \n",
        "type": "Parts.Get model c -> Parts.Set model c -> Parts.Update' model msg -> Parts.Update' c msg"
      },
      {
        "name": "embedView",
        "comment": " Lift a `view` to one which knows how to retrieve its `model` from \na c model `c`. \n",
        "type": "Parts.Get model c -> Parts.View model a -> Parts.View c a"
      },
      {
        "name": "indexed",
        "comment": " Fix a getter and setter for an `Indexed model` to a particular `Index`.\n",
        "type": "Parts.Get (Parts.Indexed model) c -> Parts.Set (Parts.Indexed model) c -> model -> ( Parts.Index -> Parts.Get model c , Parts.Index -> Parts.Set model c )"
      },
      {
        "name": "pack",
        "comment": " Partially apply an `Update` function to a `msg`, producing a generic Msg.\n",
        "type": "Parts.Update c msg -> msg -> Parts.Msg c"
      },
      {
        "name": "pack'",
        "comment": " Partially apply an explicit no-op `Update'` function to a `msg`, producing\na generic Msg.\n",
        "type": "(a -> b -> ( Maybe.Maybe b, Platform.Cmd.Cmd a )) -> a -> Parts.Msg b"
      },
      {
        "name": "update",
        "comment": " Generic update function for `Msg`. \n",
        "type": "(Parts.Msg c -> m) -> Parts.Msg c -> c -> ( c, Platform.Cmd.Cmd m )"
      },
      {
        "name": "update'",
        "comment": " Generic explict no-op update function for `Msg`. \n",
        "type": "(Parts.Msg c -> m) -> Parts.Msg c -> c -> ( Maybe.Maybe c, Platform.Cmd.Cmd m )"
      }
    ],
    "generated-with-elm-version": "0.17.0"
  }
]